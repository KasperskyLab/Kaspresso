# Паттерн Page object в Kaspresso.

## Что такое Page object? 

Паттерн Page object хорошо объяснен Мартином Фаулером в [этой статье](https://martinfowler.com/bliki/PageObject.html). Если коротко, то это тестовая абстракция, которая описывает экран с некоторыми элементами интерфейса. С этими элементами можно взаимодействовать во время тестов. В результате, описание элементов экрана будет в отдельном классе. Вам больше не нужно постоянно искать нужный UI-элемент с несколькими matcher-ами в тестах. Это можно сделать один раз, сохранив ссылку на экран.

## Как реализован паттерн Page object в Kaspresso?

Kaspresso предоставляет `KScreen` и `UiScreen` в качестве реализации паттерна Page object.

### В чем разница между KScreen и UiScreen?

Kaspresso основан на Kakao и UiAutomator. 
Когда у нас есть вся информация о коде приложения (случай «тестирования белого ящика»), мы должны использовать KScreen для описания структуры PageObject, как это делает Kakao. Это класс в Kaspresso - расширение для класса Screen из Kakao.
Когда у нас нет доступа к исходному коду приложения (это могут быть какие-то системные диалоги, окна или приложения), мы должны использовать UiScreen.
Вот два примера:

```kotlin
object SimpleScreen : KScreen<SimpleScreen>() {

    override val layoutId: Int? = R.layout.activity_simple
    override val viewClass: Class<*>? = SimpleActivity::class.java

    val button1 = KButton { withId(R.id.button_1) }

    val button2 = KButton { withId(R.id.button_2) }

    val edit = KEditText { withId(R.id.edit) }
}

object MainScreen : UiScreen<MainScreen>() {

    override val packageName: String = "com.kaspersky.kaspresso.kautomatorsample"

    val simpleEditText = UiEditText { withId(this@MainScreen.packageName, "editText") }
    val simpleButton = UiButton { withId(this@MainScreen.packageName, "button") }
    val checkBox = UiCheckBox { withId(this@MainScreen.packageName, "checkBox") }
}
```

В наследниках KScreen необходимо проинициализировать поля `layoutId` (файл макета экрана) и `viewClass`(имя класса экрана - activity или fragment). Эти поля можно проинициализировать значением `null`, но рекомендуется присвоить им корректные значения. Они помогут поддерживать, модифицировать и отлаживать тесты, сохраняя информацию о связанных с конкретным тестом файлах в основом коде приложения. В случае рефакторинга основного кода приложения, разработчик также увидит, что некоторые тесты завязаны на этот код.
В наследниках UiScreen необходимо проинициализировать поле `packageName` (полное имя пакета приложения). 

## Преимущества паттерна Page object для рефакторинга
Применение этого паттерна позволяет вынести описание экрана в отдельный файл и повторно использовать экраны и ссылки на UI-элементы в разных тестах. Когда у вас есть некоторые изменения в пользовательском интерфейсе приложения, вы можете изменить только код в файле экрана без необходимости большого рефакторинга тестов. 

## Преимущества Page Object для работы в команде
В одних командах автотесты пишут только разработчики, в других QA инженеры. В некоторых случаях автотесты пишет кто-то, кто не знает деталей кода (исходный код есть, но плохо понятен). В этом случае разработчики могут написать сущности Screen для дальнейших автотестов. Наличие реализованных экранов (Page object Screen) помогает другому человеку писать тесты с использованием Kotlin DSL. 
